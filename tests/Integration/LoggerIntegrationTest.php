<?php

namespace CodeDistortion\ClarityLogger\Tests\Integration;

use CodeDistortion\ClarityContext\Clarity;
use CodeDistortion\ClarityLogger\Logger;
use CodeDistortion\ClarityLogger\Settings;
use CodeDistortion\ClarityLogger\Tests\LaravelTestCase;
use Exception;
use Illuminate\Support\Facades\Log;

/**
 * Test the Logger class.
 *
 * @phpcs:disable PSR1.Methods.CamelCapsMethodName.NotCamelCaps
 */
class LoggerIntegrationTest extends LaravelTestCase
{
    /**
     * Test that *something* is logged when an exception is reported.
     *
     * @test
     *
     * @return void
     */
    public static function test_exception_reporting(): void
    {
        $argCheck = fn($level, $output) => ($level === Settings::REPORTING_LEVEL_ERROR) && (mb_strlen($output) > 0);

        Log::shouldReceive('channel')->withArgs(['stack'])->once()->andReturnSelf();
        Log::shouldReceive('log')->withArgs($argCheck)->once()->andReturnSelf();

        $exception = new Exception();
        Logger::log($exception);
    }

    /**
     * Test that *something* is logged when the user manually reports something.
     *
     * @test
     * @dataProvider manualLoggingDataProvider
     *
     * @param string $level The reporting level to use.
     * @return void
     */
    public static function test_manual_reporting(string $level): void
    {
        $argCheck = fn($level2, $output) => ($level2 === $level) && (mb_strlen($output) > 0);

        Log::shouldReceive('channel')->withArgs(['stack'])->once()->andReturnSelf();
        Log::shouldReceive('log')->withArgs($argCheck)->once()->andReturnSelf();

        Logger::$level('hello');
    }

    /**
     * Test that *something* is logged when the user manually reports something, with a channel specified.
     *
     * @test
     * @dataProvider manualLoggingDataProvider
     *
     * @param string $level The reporting level to use.
     * @return void
     */
    public static function test_manual_reporting_with_channel(string $level): void
    {
        $argCheck = fn($level2, $output) => ($level2 === $level) && (mb_strlen($output) > 0);

        Log::shouldReceive('channel')->withArgs(['slack'])->once()->andReturnSelf();
        Log::shouldReceive('log')->withArgs($argCheck)->once()->andReturnSelf();

        Logger::channel('slack')->$level('hello');
    }

    /**
     * DataProvider for test_manual_reporting() and test_manual_reporting_with_channel().
     *
     * @return array<array<string, string>>
     */
    public static function manualLoggingDataProvider(): array
    {
        return [
            ['level' => Settings::REPORTING_LEVEL_DEBUG],
            ['level' => Settings::REPORTING_LEVEL_INFO],
            ['level' => Settings::REPORTING_LEVEL_NOTICE],
            ['level' => Settings::REPORTING_LEVEL_WARNING],
            ['level' => Settings::REPORTING_LEVEL_ERROR],
            ['level' => Settings::REPORTING_LEVEL_CRITICAL],
            ['level' => Settings::REPORTING_LEVEL_ALERT],
            ['level' => Settings::REPORTING_LEVEL_EMERGENCY],
        ];
    }



    /**
     * Test the output generated by the Logger class. This is intended to check the output when Clarity Context is and
     * isn't installed (GitHub actions runs the tests with and without).
     *
     * @return void
     */
    public static function test_logger_output(): void
    {
        $contextLine = null;
        if (class_exists(Clarity::class)) {
            Clarity::traceIdentifier('12345');
            Clarity::context('Sending an invoice', ['invoice-id' => 123, 'user-id' => 99]);
            $contextLine = __LINE__ - 1;
        }

        $exception = new Exception();
        $exceptionLine = __LINE__ - 1;

        $file = 'tests/Integration/LoggerIntegrationTest.php';
        $file = str_replace('/', DIRECTORY_SEPARATOR, $file);

        $expected = 'EXCEPTION (CAUGHT):' . PHP_EOL
            . PHP_EOL
            . 'exception   Exception: ""' . PHP_EOL
            . '- location  ' . $file . ' on line ' . $exceptionLine . ' (method "test_logger_output")' . PHP_EOL
            . 'command' . PHP_EOL
            . '- user' . PHP_EOL;

        if (class_exists(Clarity::class)) {
            $expected .= '- trace-id  12345' . PHP_EOL;
        }

        $expected .= 'date/time';

        if (class_exists(Clarity::class)) {
            $expected .= PHP_EOL
                . PHP_EOL
                . 'CONTEXT DETAILS:' . PHP_EOL
                . PHP_EOL
                . $file . ' on line ' . $contextLine . ' (method "test_logger_output")' . PHP_EOL
                . '- "Sending an invoice"' . PHP_EOL
                . '- invoice-id = 123' . PHP_EOL
                . '- user-id = 99' . PHP_EOL
                . PHP_EOL
                . $file . ' on line ' . $exceptionLine . ' (method "test_logger_output")' . PHP_EOL
                . '- The exception was thrown';
        }



        // ensure the output is as expected
        $argCheck = function ($level, $output) use ($expected): bool {
            // remove lines with content that varies
            $output = self::replaceLineStartingWith('command  ', 'command', $output);
            $output = self::replaceLineStartingWith('- user  ', '- user', $output);
            $output = self::replaceLineStartingWith('date/time  ', 'date/time', $output);

            self::assertSame($expected, $output);
            return true;
        };

        Log::shouldReceive('channel')->once()->andReturnSelf();
        Log::shouldReceive('log')->withArgs($argCheck)->once()->andReturnSelf();



        Logger::debug($exception);
    }

    /**
     * Look through the lines and remove ones that start with a particular string.
     *
     * @param string $needle   The string to look for.
     * @param string $replace  The string to replace it with.
     * @param string $haystack The string to look in.
     * @return string
     */
    private static function replaceLineStartingWith(string $needle, string $replace, string $haystack): string
    {
        $lines = explode(PHP_EOL, $haystack);

        foreach ($lines as $index => $line) {
            if (str_starts_with($line, $needle)) {
                $lines[$index] = $replace;
            }
        }

        return implode(PHP_EOL, $lines);
    }
}
