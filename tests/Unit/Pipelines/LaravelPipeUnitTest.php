<?php

namespace CodeDistortion\ClarityLogger\Tests\Unit\Pipelines;

use Carbon\Carbon;
use Carbon\CarbonImmutable;
use CodeDistortion\ClarityContext\API\MetaCallStackAPI;
use CodeDistortion\ClarityContext\Clarity;
use CodeDistortion\ClarityContext\Context;
use CodeDistortion\ClarityContext\Support\InternalSettings;
use CodeDistortion\ClarityControl\Control;
use CodeDistortion\ClarityLogger\Pipelines\PipelineInput;
use CodeDistortion\ClarityLogger\Pipelines\PipelineOutput;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\PipeInterface;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\ClarityContextPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\ClarityKnownIssuesPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\CommandPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\ContextArrayPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\ExceptionPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\InternalExceptionsPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\MessagePipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\OccurredAtPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\RequestPipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\TitlePipe;
use CodeDistortion\ClarityLogger\Pipelines\Pipes\Text\UserPipe;
use CodeDistortion\ClarityLogger\Renderers\Laravel\TextRenderer;
use CodeDistortion\ClarityLogger\Settings;
use CodeDistortion\ClarityLogger\Support\Framework\Framework;
use CodeDistortion\ClarityLogger\Tests\LaravelTestCase;
use CodeDistortion\ClarityLogger\Tests\TestSupport\ExceptionDTO;
use CodeDistortion\ClarityLogger\Tests\TestSupport\UserModel;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Routing\Route;
use ReflectionClass;
use Throwable;

/**
 * Test the output generated by the various Pipe classes.
 *
 * @phpcs:disable PSR1.Methods.CamelCapsMethodName.NotCamelCaps
 */
class LaravelPipeUnitTest extends LaravelTestCase
{
    /**
     * Test the output that the ClarityContextPipe class generates.
     *
     * @return void
     */
    public static function test_clarity_context_pipe(): void
    {
        // WITHOUT a Clarity Context object
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // WITH a Clarity Context object (that's not worth reporting)
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
            useClarityContext: true,
            overridePipePrivates: ['overrideDetailsAreWorthListing' => false],
        );

        // WITH a Clarity Context object
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
        );

        // WITH a Clarity Context object - including the "last application frame"
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure) (last application frame)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            overridePipePrivates: ['overrideShowAsLastAppFrame' => true],
        );

        // WITH a Clarity Context object + 1 x context data (array with one element)
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- id = 123' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [[['id' => 123]]],
        );

        // WITH a Clarity Context object + 1 x context data (array with two elements)
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- id1 = 123' . PHP_EOL
            . '- id2 = 456' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [[['id1' => 123, 'id2' => 456]]],
        );

        // WITH a Clarity Context object + 1 x context data (string)
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- "hello"' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [['hello']],
        );

        // WITH a Clarity Context object + 2 x context data (string)
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- "hello1"' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_2% (method "runPipeTest")' . PHP_EOL
            . '- "hello2"' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [['hello1'], ['hello2']],
        );

        // WITH a Clarity Context object + 2 x context data (string)
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- "hello1"' . PHP_EOL
            . '- id1 = 123' . PHP_EOL
            . '- id2 = 456' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_2% (method "runPipeTest")' . PHP_EOL
            . '- id3 = 789' . PHP_EOL
            . '- id4 = 111' . PHP_EOL
            . '- "hello2"' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [
                ['hello1', ['id1' => 123, 'id2' => 456]],
                [['id3' => 789, 'id4' => 111], 'hello2'],
            ],
        );


        // WITH a Clarity Context object + 2 x context data (string) - in STACK TRACE (i.e. reverse) ORDER
        $output = 'CONTEXT DETAILS:' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXTS_EXCEPTION_THROWN_LINE% (closure)' . PHP_EOL
            . '- The exception was thrown' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_2% (method "runPipeTest")' . PHP_EOL
            . '- id3 = 789' . PHP_EOL
            . '- id4 = 111' . PHP_EOL
            . '- "hello2"' . PHP_EOL
            . PHP_EOL
            . '%TEST_PATH% on line %CONTEXT_METADATA_LINE_1% (method "runPipeTest")' . PHP_EOL
            . '- "hello1"' . PHP_EOL
            . '- id1 = 123' . PHP_EOL
            . '- id2 = 456';
        self::runPipeTest(
            pipeClass: ClarityContextPipe::class,
            pipelineInput: self::newPipelineInput(useCallStackOrder: false),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            arrayOfContextMetaData: [
                ['hello1', ['id1' => 123, 'id2' => 456]],
                [['id3' => 789, 'id4' => 111], 'hello2'],
            ],
        );
    }



    /**
     * Test the output that the ClarityKnownIssuesPipe class generates.
     *
     * @return void
     */
    public static function test_clarity_known_issues_pipe(): void
    {
        // WITHOUT a Clarity Context object
        self::runPipeTest(
            pipeClass: ClarityKnownIssuesPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // with no "known" issues
        self::runPipeTest(
            pipeClass: ClarityKnownIssuesPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
            updateControlObject: fn(Control $control) => $control->known([]),
        );

        // with one "known" issue
        self::runPipeTest(
            pipeClass: ClarityKnownIssuesPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'known  https://known.com/123',
            expectedErrorOutput: 'known  https://known.com/123',
            updateControlObject: fn(Control $control) => $control->known(['https://known.com/123']),
            useClarityContext: true,
        );

        // with two "known" issues
        $output = 'known  https://known.com/123' . PHP_EOL
                . '       https://known.com/456';
        self::runPipeTest(
            pipeClass: ClarityKnownIssuesPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            updateControlObject: fn(Control $control) => $control->known(
                ['https://known.com/123', 'https://known.com/456']
            ),
            useClarityContext: true,
        );
    }



    /**
     * Test the output that the CommandPipe class generates.
     *
     * @return void
     */
    public static function test_command_pipe(): void
    {

        // with a COMMAND, but without a Context object
        $output = 'command  test-command abc --xyz' . PHP_EOL
            . '- user   ' . get_current_user();
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(consoleCommand: 'test-command abc --xyz'),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // with a COMMAND
        $output = 'command  test-command abc --xyz' . PHP_EOL
            . '- user   ' . get_current_user();
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(consoleCommand: 'test-command abc --xyz'),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // with an empty COMMAND
        $output = 'command  (unknown)' . PHP_EOL
            . '- user   ' . get_current_user();
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(consoleCommand: ''),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // with a REQUEST
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
            request: self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/'),
        );

        // with a COMMAND, with a trace identifier
        $output = 'command     test-command abc --xyz' . PHP_EOL
            . '- user      ' . get_current_user() . PHP_EOL
            . '- trace-id  1234';
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(consoleCommand: 'test-command abc --xyz'),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234],
        );

        // with a COMMAND, with two trace identifiers
        $output = 'command      test-command abc --xyz' . PHP_EOL
            . '- user       ' . get_current_user() . PHP_EOL
            . '- trace-ids  1234' . PHP_EOL
            . '             abc: 4-5-6-7';
        self::runPipeTest(
            pipeClass: CommandPipe::class,
            pipelineInput: self::newPipelineInput(consoleCommand: 'test-command abc --xyz'),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234, 'abc' => '4-5-6-7'],
        );
    }



    /**
     * Test the output that the ContextArrayPipe class generates.
     *
     * @return void
     */
    public static function test_context_array_pipe(): void
    {
        // WITHOUT a context array
        self::runPipeTest(
            pipeClass: ContextArrayPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // WITH a context array (1 value)
        $output = 'context  id = 123';
        self::runPipeTest(
            pipeClass: ContextArrayPipe::class,
            pipelineInput: self::newPipelineInput(callerContextArray: ['id' => 123]),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // WITH a context array (2 values)
        $output = 'context  id1 = 123' . PHP_EOL
                . '         id2 = 456';
        self::runPipeTest(
            pipeClass: ContextArrayPipe::class,
            pipelineInput: self::newPipelineInput(callerContextArray: ['id1' => 123, 'id2' => 456]),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );
    }



    /**
     * Test the output that the ExceptionPipe class generates.
     *
     * @return void
     */
    public static function test_exception_pipe(): void
    {
        // without an exception
        self::runPipeTest(
            pipeClass: ExceptionPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // with an exception
        $output = 'exception   Exception: "something happened"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
        self::runPipeTest(
            pipeClass: ExceptionPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            exceptionDTOs: [new ExceptionDTO('something happened')],
        );

        // with an exception (with a previous exception)
        $output = 'exception   Exception: "something happened 1"' . PHP_EOL
            . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
            . 'prev-ex.    Exception: "something happened 2"' . PHP_EOL
            . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
        self::runPipeTest(
            pipeClass: ExceptionPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            exceptionDTOs: [
                new ExceptionDTO('something happened 1'),
                new ExceptionDTO('something happened 2'),
            ],
        );

        // with an exception (with two previous exceptions)
        $output = 'exception   Exception: "something happened 1"' . PHP_EOL
            . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
            . 'prev-ex.    Exception: "something happened 2"' . PHP_EOL
            . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
            . 'prev-ex. 2  Exception: "something happened 3"' . PHP_EOL
            . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
        self::runPipeTest(
            pipeClass: ExceptionPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            exceptionDTOs: [
                new ExceptionDTO('something happened 1'),
                new ExceptionDTO('something happened 2'),
                new ExceptionDTO('something happened 3'),
            ],
        );

        // with an exception that was generated in a function
        $output = 'exception   Exception: "something happened"' . PHP_EOL
            . '- location  %FUNCTIONS_PATH_LONG% on line 10 (function "newExceptionFromFunction")';
        self::runPipeTest(
            pipeClass: ExceptionPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            exceptionDTOs: [new ExceptionDTO('something happened')],
            exception: newExceptionFromFunction(),
        );
    }



    /**
     * Test the output that the InternalExceptionsPipe class generates
     * - when no internal exception occurred.
     * - when internal exception/s occurred - but no regular exception.
     * - when internal exception/s occurred as well as a regular exception.
     *
     * @return void
     */
    public static function test_internal_exception_pipe_without_a_regular_exception(): void
    {
        $exceptions = [null, new Exception()];
        foreach ($exceptions as $exception) {

            $title = $exception ? 'NEW EXCEPTION' : 'EXCEPTION';



            // with NO internal exception
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: '',
                exception: $exception,
            );



            // with an internal exception
            $output = "{$title} (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception   Exception: "something happened"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [new ExceptionDTO('something happened')],
            );

            // with an internal exception (with a previous exception)
            $output = "{$title} (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception   Exception: "something happened 1"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.    Exception: "something happened 2"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [
                    new ExceptionDTO('something happened 1'),
                    new ExceptionDTO('something happened 2'),
                ],
            );

            // with an internal exception (with two previous exceptions)
            $output = "{$title} (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception   Exception: "something happened 1"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.    Exception: "something happened 2"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex. 2  Exception: "something happened 3"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [
                    new ExceptionDTO('something happened 1'),
                    new ExceptionDTO('something happened 2'),
                    new ExceptionDTO('something happened 3'),
                ],
            );


            // with two internal exceptions
            $output = "{$title}S (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception 1  Exception: "A something happened"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . PHP_EOL
                . 'exception 2  Exception: "B something happened"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [new ExceptionDTO('A something happened')],
                internalException2DTOs: [new ExceptionDTO('B something happened')],
            );

            // with two internal exceptions (with a previous exception)
            $output = "{$title}S (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception 1  Exception: "A something happened 1"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.     Exception: "A something happened 2"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . PHP_EOL
                . 'exception 2  Exception: "B something happened 1"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.     Exception: "B something happened 2"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [
                    new ExceptionDTO('A something happened 1'),
                    new ExceptionDTO('A something happened 2'),
                ],
                internalException2DTOs: [
                    new ExceptionDTO('B something happened 1'),
                    new ExceptionDTO('B something happened 2'),
                ],
            );

            // with two internal exceptions (with two previous exceptions)
            $output = "{$title}S (that occurred when building the report)" . PHP_EOL
                . PHP_EOL
                . 'exception 1  Exception: "A something happened 1"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.     Exception: "A something happened 2"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex. 2   Exception: "A something happened 3"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . PHP_EOL
                . 'exception 2  Exception: "B something happened 1"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex.     Exception: "B something happened 2"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")' . PHP_EOL
                . 'prev-ex. 2   Exception: "B something happened 3"' . PHP_EOL
                . '- location   %TEST_PATH_LONG% on line %EXCEPTION_THROWN_LINE% (method "buildException")';
            self::runPipeTest(
                pipeClass: InternalExceptionsPipe::class,
                pipelineInput: self::newPipelineInput(),
                expectedOutput: '',
                expectedErrorOutput: $output,
                exception: $exception,
                internalException1DTOs: [
                    new ExceptionDTO('A something happened 1'),
                    new ExceptionDTO('A something happened 2'),
                    new ExceptionDTO('A something happened 3'),
                ],
                internalException2DTOs: [
                    new ExceptionDTO('B something happened 1'),
                    new ExceptionDTO('B something happened 2'),
                    new ExceptionDTO('B something happened 3'),
                ],
            );
        }
    }



    /**
     * Test the output that the MessagePipe class generates.
     *
     * @return void
     */
    public static function test_message_pipe(): void
    {
        // WITHOUT a message
        self::runPipeTest(
            pipeClass: MessagePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // WITH a message
        $output = 'message     "hello"' . PHP_EOL
                . '- location  %TEST_PATH_LONG% on line %CALLER_LINE% (method "pipeCall")';
        self::runPipeTest(
            pipeClass: MessagePipe::class,
            pipelineInput: self::newPipelineInput(callerMessage: 'hello'),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );
    }



    /**
     * Test the output that the OccurredAtPipe class generates.
     *
     * @return void
     */
    public static function test_occurred_at_pipe(): void
    {
        $defaultFormat = ['l', 'jS', 'F', '\a\t g:ia', '(e)', '', 'Y-m-d H:i:s', 'T', 'P'];

        // WITHOUT a date/time
        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // WITH a date/time, default format, default timezone
        $occurredAtUTC = CarbonImmutable::now('UTC');
        $timezones = ['UTC'];
        $format = $defaultFormat;
        $timeStrings = self::formatTimeStrings($occurredAtUTC, $timezones, $format);
        $output = self::buildTimeStrings($timeStrings);

        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(
                timezones: $timezones,
                dateTimeFormat: $format,
                occurredAt: $occurredAtUTC,
            ),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // WITH a date/time, custom format, default timezone
        $occurredAtUTC = CarbonImmutable::now('UTC');
        $timezones = ['UTC'];
        $format = ['Y-m-d H:i:s', 'r'];
        $timeStrings = self::formatTimeStrings($occurredAtUTC, $timezones, $format);
        $output = self::buildTimeStrings($timeStrings);

        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(
                timezones: $timezones,
                dateTimeFormat: $format,
                occurredAt: $occurredAtUTC,
            ),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // WITH a date/time, default format, custom timezone
        $occurredAtUTC = CarbonImmutable::now('UTC');
        $timezones = ['Australia/Sydney'];
        $format = $defaultFormat;
        $timeStrings = self::formatTimeStrings($occurredAtUTC, $timezones, $format);
        $output = self::buildTimeStrings($timeStrings);

        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(
                timezones: $timezones,
                dateTimeFormat: $format,
                occurredAt: $occurredAtUTC,
            ),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // WITH a date/time, default format, two custom timezones
        $occurredAtUTC = CarbonImmutable::now('UTC');
        $timezones = ['Australia/Sydney', 'UTC'];
        $format = $defaultFormat;
        $timeStrings = self::formatTimeStrings($occurredAtUTC, $timezones, $format);
        $output = self::buildTimeStrings($timeStrings);

        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(
                timezones: $timezones,
                dateTimeFormat: $format,
                occurredAt: $occurredAtUTC,
            ),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );

        // WITH a date/time, default format, multiple custom timezones
        $occurredAtUTC = CarbonImmutable::now('UTC');
        $timezones = ['Australia/Sydney', 'UTC', 'America/New_York', 'Europe/London'];
        $format = $defaultFormat;
        $timeStrings = self::formatTimeStrings($occurredAtUTC, $timezones, $format);
        $output = self::buildTimeStrings($timeStrings);

        self::runPipeTest(
            pipeClass: OccurredAtPipe::class,
            pipelineInput: self::newPipelineInput(
                timezones: $timezones,
                dateTimeFormat: $format,
                occurredAt: $occurredAtUTC,
            ),
            expectedOutput: $output,
            expectedErrorOutput: $output,
        );
    }



    /**
     * Test the output that the RequestPipe class generates - when not using a route.
     *
     * @return void
     */
    public static function test_request_pipe_without_a_route(): void
    {
        // WITHOUT a request
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );



        // WITH a GET request
        $output = 'request  GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
                . '- route  (unavailable)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );

        // WITH a GET request - with a referrer
        $output = 'request     GET https://test.com/123?abc=def' . PHP_EOL
            . '- referrer  https://abc.net/' . PHP_EOL
            . '- route     (unavailable)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/'),
        );



        // WITH a POST request - with a referrer
        $output = 'request  POST https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route  (unavailable)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'POST'),
        );



        // WITH a GET request and a trace identifier
        $output = 'request     GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route     (unavailable)' . PHP_EOL
            . '- trace-id  1234';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234],
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );

        // WITH a GET request and two trace identifiers
        $output = 'request      GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route      (unavailable)' . PHP_EOL
            . '- trace-ids  1234' . PHP_EOL
            . '             abc: 4-5-6-7';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234, 'abc' => '4-5-6-7'],
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );
    }

    /**
     * Test the output that the RequestPipe class generates - when using a class-based route.
     *
     * @return void
     */
    public static function test_request_pipe_with_a_class_based_route(): void
    {
        // WITH a GET request - with UNNAMED route, no middleware
        $route = new Route('GET', '/123', ['TestController', 'method']);
        $output = 'request       GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       (unnamed)' . PHP_EOL
            . '- middleware  n/a' . PHP_EOL
            . '- action      TestController@method';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', null, $route),
        );



        // WITH a GET request - with NAMED route, no middleware
        $route = new Route('GET', '/123', ['TestController', 'method']);
        $route->name('some.route');
        $output = 'request       GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  n/a' . PHP_EOL
            . '- action      TestController@method';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', null, $route),
        );



        // WITH a GET request - with UNNAMED route, and 1 x middleware
        $route = new Route('GET', '/123', ['TestController', 'method']);
        $route->middleware('middleware1');
        $output = 'request       GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       (unnamed)' . PHP_EOL
            . '- middleware  middleware1' . PHP_EOL
            . '- action      TestController@method';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', null, $route),
        );



        // WITH a GET request - with NAMED route, and 1 x middleware
        $route = new Route('GET', '/123', ['TestController', 'method']);
        $route->name('some.route');
        $route->middleware('middleware1');
        $output = 'request       GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  middleware1' . PHP_EOL
            . '- action      TestController@method';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', null, $route),
        );



        // WITH a GET request - with NAMED route, and 2 x middleware
        $route = new Route('GET', '/123', ['TestController', 'method']);
        $route->name('some.route');
        $route->middleware('middleware1');
        $route->middleware('middleware2');
        $output = 'request       GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  middleware1, middleware2' . PHP_EOL
            . '- action      TestController@method';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', null, $route),
        );
    }

    /**
     * Test the output that the RequestPipe class generates - when using a closure-based route.
     *
     * @return void
     */
    public static function test_request_pipe_with_a_closure_based_route(): void
    {
        // WITH a DELETE request - with UNNAMED route, no middleware
        $route = new Route('DELETE', '/123', fn() => 'some closure');
        $output = 'request       DELETE https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       (unnamed)' . PHP_EOL
            . '- middleware  n/a' . PHP_EOL
            . '- action      (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'DELETE', null, $route),
        );



        // WITH a DELETE request - with NAMED route, no middleware
        $route = new Route('DELETE', '/123', fn() => 'some closure');
        $route->name('some.route');
        $output = 'request       DELETE https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  n/a' . PHP_EOL
            . '- action      (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'DELETE', null, $route),
        );



        // WITH a DELETE request - with UNNAMED route, and 1 x middleware
        $route = new Route('DELETE', '/123', fn() => 'some closure');
        $route->middleware('middleware1');
        $output = 'request       DELETE https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       (unnamed)' . PHP_EOL
            . '- middleware  middleware1' . PHP_EOL
            . '- action      (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'DELETE', null, $route),
        );



        // WITH a DELETE request - with NAMED route, and 1 x middleware
        $route = new Route('DELETE', '/123', fn() => 'some closure');
        $route->name('some.route');
        $route->middleware('middleware1');
        $output = 'request       DELETE https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  middleware1' . PHP_EOL
            . '- action      (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'DELETE', null, $route),
        );



        // WITH a DELETE request - with NAMED route, and 2 x middleware
        $route = new Route('DELETE', '/123', fn() => 'some closure');
        $route->name('some.route');
        $route->middleware('middleware1');
        $route->middleware('middleware2');
        $output = 'request       DELETE https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route       some.route' . PHP_EOL
            . '- middleware  middleware1, middleware2' . PHP_EOL
            . '- action      (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'DELETE', null, $route),
        );
    }

    /**
     * Test the output that the RequestPipe class generates - when using excluded middleware.
     *
     * @return void
     */
    public static function test_request_pipe_with_a_closure_based_route_and_excluded_middleware(): void
    {
        // WITH a POST request - with UNNAMED route, no middleware, and 1 x excluded middleware
        $route = new Route('POST', '/123', ['TestController', 'method']);
        $route->uses(fn() => 'some closure');
        $route->withoutMiddleware('exclude middleware 1');
        $output = 'request             POST https://test.com/123?abc=def (no referrer)' . PHP_EOL
                . '- route             (unnamed)' . PHP_EOL
                . '- middleware        n/a' . PHP_EOL
                . '- excl. middleware  exclude middleware 1' . PHP_EOL
                . '- action            (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'POST', null, $route),
        );



        // WITH a POST request - with NAMED route, and 1 x middleware, and 2 x excluded middleware
        $route = new Route('POST', '/123', ['TestController', 'method']);
        $route->name('some.route');
        $route->middleware('middleware1');
        $route->withoutMiddleware('exclude middleware 1');
        $route->withoutMiddleware('exclude middleware 2');
        $route->uses(fn() => 'some closure');
        $output = 'request             POST https://test.com/123?abc=def (no referrer)' . PHP_EOL
                . '- route             some.route' . PHP_EOL
                . '- middleware        middleware1' . PHP_EOL
                . '- excl. middleware  exclude middleware 1, exclude middleware 2' . PHP_EOL
                . '- action            (closure)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'POST', null, $route),
        );
    }

    /**
     * Test the output that the RequestPipe class generates - when using trace identifiers.
     *
     * @return void
     */
    public static function test_request_pipe_trace_identifiers(): void
    {
        // WITH a GET request - and no Context object
        $output = 'request  GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route  (unavailable)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );



        // WITH a GET request and no trace identifiers
        $output = 'request  GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route  (unavailable)';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );



        // WITH a GET request and a trace identifier
        $output = 'request     GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route     (unavailable)' . PHP_EOL
            . '- trace-id  1234';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234],
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );

        // WITH a GET request and two trace identifiers
        $output = 'request      GET https://test.com/123?abc=def (no referrer)' . PHP_EOL
            . '- route      (unavailable)' . PHP_EOL
            . '- trace-ids  1234' . PHP_EOL
            . '             abc: 4-5-6-7';
        self::runPipeTest(
            pipeClass: RequestPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            useClarityContext: true,
            traceIdentifiers: ['' => 1234, 'abc' => '4-5-6-7'],
            request: self::newRequest('https://test.com/123?abc=def', 'GET'),
        );
    }



    /**
     * Test the output that the TitlePipe class generates.
     *
     * @return void
     */
    public static function test_title_pipe(): void
    {
        // WITHOUT an exception
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'CUSTOM MESSAGE:',
            expectedErrorOutput: 'CUSTOM MESSAGE:',
        );



        // WITH an exception - when the exception WAS caught
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'EXCEPTION (CAUGHT):',
            expectedErrorOutput: 'EXCEPTION (CAUGHT):',
            exceptionDTOs: [new ExceptionDTO('something happened')],
        );

        // WITH an exception - when the exception was NOT caught
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'EXCEPTION (UNCAUGHT):',
            expectedErrorOutput: 'EXCEPTION (UNCAUGHT):',
            exceptionDTOs: [new ExceptionDTO('something happened')],
            overridePipePrivates: ['overrideCheckIfReporting' => false]
        );



        // WITHOUT an exception but with an internal exception
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'CUSTOM MESSAGE:',
            expectedErrorOutput: 'CUSTOM MESSAGE:',
            internalException1DTOs: [new ExceptionDTO('something happened')],
        );

        // WITH an exception and an internal exception - when the exception WAS caught
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'EXCEPTION (CAUGHT):',
            expectedErrorOutput: 'ORIGINAL EXCEPTION (CAUGHT):',
            exceptionDTOs: [new ExceptionDTO('something happened')],
            internalException1DTOs: [new ExceptionDTO('something happened')],
        );

        // WITH an exception and an internal exception - when the exception was NOT caught
        self::runPipeTest(
            pipeClass: TitlePipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: 'EXCEPTION (UNCAUGHT):',
            expectedErrorOutput: 'ORIGINAL EXCEPTION (UNCAUGHT):',
            exceptionDTOs: [new ExceptionDTO('something happened')],
            internalException1DTOs: [new ExceptionDTO('something happened')],
            overridePipePrivates: ['overrideCheckIfReporting' => false],
        );
    }



    /**
     * Test the output that the UserPipe class generates.
     *
     * @return void
     */
    public static function test_user_pipe(): void
    {
        // WITHOUT a request
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: '',
            expectedErrorOutput: '',
        );

        // WITH a request - guest user
        $output = 'user     (guest) (127.0.0.1)' . PHP_EOL
                . '- agent  Symfony';
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/'),
        );

        // WITH a request - guest user - custom user-agent
        $request = self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/');
        $request->headers->add(['User-Agent' => 'Something, somewhere']);
        $output = 'user     (guest) (127.0.0.1)' . PHP_EOL
            . '- agent  Something, somewhere';
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: $request,
        );

        // WITH a request - guest user - custom ip address
        $request = self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/');
        $request->server->add(['REMOTE_ADDR' => '1.2.3.4']);
        $output = 'user     (guest) (1.2.3.4)' . PHP_EOL
            . '- agent  Symfony';
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: $request,
        );

        // WITH a request - and a logged-in user
        $user = new UserModel([
            'id' => mt_rand(1, 1000),
            'name' => 'Bob',
            'email' => 'test@test.com'
        ]);
        $request = self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/');
        $request->setUserResolver(fn() => $user);

        $output = "user     $user->id - $user->name - $user->email (127.0.0.1)" . PHP_EOL
            . '- agent  Symfony';
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            request: $request,
        );

        // WITH a request - and a logged-in user - throws an error when adding the user's details
        $user = new UserModel([
            'id' => mt_rand(1, 1000),
            'name' => 'Bob',
            'email' => 'test@test.com'
        ]);
        $request = self::newRequest('https://test.com/123?abc=def', 'GET', 'https://abc.net/');
        $request->setUserResolver(fn() => $user);

        $output = "user     (127.0.0.1)" . PHP_EOL
            . '- agent  Symfony';
        self::runPipeTest(
            pipeClass: UserPipe::class,
            pipelineInput: self::newPipelineInput(),
            expectedOutput: $output,
            expectedErrorOutput: $output,
            overridePipePrivates: ['throwTestingException' => true],
            request: $request,
        );
    }









    /**
     * Build a new PipelineInput instance.
     *
     * @param string                      $projectRootDir     The project root-dir.
     * @param boolean                     $runningInConsole   Whether the code is running from the console or not.
     * @param string|null                 $consoleCommand     The console command being run.
     * @param class-string                $defaultRenderer    The default renderer to use.
     * @param array<string, class-string> $channelRenderers   The renderers for a particular channels.
     * @param string[]                    $timezones          The timezones to render dates/times in.
     * @param string[]                    $dateTimeFormat     The format to render dates/times in.
     * @param string                      $prefix             The prefix to use.
     * @param boolean                     $useCallStackOrder  Use call stack order (or stack trace order)?.
     * @param string                      $channel            The channel being reported to.
     * @param string                      $level              The reporting level being used.
     * @param string|null                 $callerMessage      The caller-specified message.
     * @param Throwable|null              $exception          The exception to report.
     * @param mixed[]                     $callerContextArray The array of context details the caller reported.
     * @param Context|null                $clarityContext     The Clarity Context object to report.
     * @param Carbon|CarbonImmutable|null $occurredAt         When the exception occurred.
     * @return PipelineInput
     */
    private static function newPipelineInput(
        string $projectRootDir = '',
        bool $runningInConsole = true,
        ?string $consoleCommand = '----',
        string $defaultRenderer = TextRenderer::class,
        array $channelRenderers = [],
        array $timezones = ['UTC'],
        array $dateTimeFormat = ['r'],
        string $prefix = '',
        bool $useCallStackOrder = true,
        string $channel = 'stack',
        string $level = Settings::REPORTING_LEVEL_DEBUG,
        ?string $callerMessage = null,
        ?Throwable $exception = null,
        array $callerContextArray = [],
        ?Context $clarityContext = null,
        Carbon|CarbonImmutable|null $occurredAt = null,
    ): PipelineInput {

        $args = [
            'projectRootDir' => $projectRootDir,
            'runningInConsole' => $runningInConsole,
            'consoleCommand' => $consoleCommand,
            'defaultRenderer' => $defaultRenderer,
            'channelRenderers' => $channelRenderers,
            'timezones' => $timezones,
            'dateTimeFormat' => $dateTimeFormat,
            'prefix' => $prefix,
            'useCallStackOrder' => $useCallStackOrder,
            'channel' => $channel,
            'level' => $level,
            'callerMessage' => $callerMessage,
            'exception' => $exception,
            'callerContextArray' => $callerContextArray,
            'clarityContext' => $clarityContext,
            'occurredAt' => $occurredAt,
        ];

        return new PipelineInput(...$args);
    }

    /**
     * Build a new Request instance.
     *
     * @param string      $url      The url to use.
     * @param string      $method   The HTTP method.
     * @param string|null $referrer The referrer to use.
     * @param Route|null  $route    The route to use.
     * @return Request
     */
    private static function newRequest(
        string $url,
        string $method = 'GET',
        ?string $referrer = null,
        ?Route $route = null
    ): Request {

        $request = Request::create($url, $method);

        if ($referrer) {
            $request->headers->add(['Referer' => $referrer]);
        }

        if ($route) {
            $request->setRouteResolver(fn () => $route);
        }

        return $request;
    }





    /**
     * Test a Pipe class, allowing for the caller to configure the various inputs.
     *
     * @param string                                     $pipeClass              The Pipe class to use.
     * @param PipelineInput                              $pipelineInput          The PipelineInput instance to use.
     * @param string                                     $expectedOutput         The expected output.
     * @param string                                     $expectedErrorOutput    The expected output when an internal
     *                                                                           exception occurs.
     * @param callable|null                              $updateControlObject    A callable to update the control
     *                                                                           object.
     * @param boolean                                    $useClarityContext      Whether to use a Clarity Context object
     *                                                                           or not.
     * @param array<string,string|integer>               $traceIdentifiers       The trace identifiers to use.
     * @param array<array<string|array<string,integer>>> $arrayOfContextMetaData Meta-data to add to the context.
     * @param ExceptionDTO[]                             $exceptionDTOs          ExceptionDTOs to build an Exception
     *                                                                           from, added to $pipelineInput.
     * @param Throwable|null                             $exception              An Exception to override the one built
     *                                                                           from $exceptionDTOs.
     * @param ExceptionDTO[]                             $internalException1DTOs ExceptionDTOs to build an internal
     *                                                                           Exception from.
     * @param ExceptionDTO[]                             $internalException2DTOs ExceptionDTOs to build a chained
     *                                                                           internal Exception from.
     * @param array<string,mixed>                        $overridePipePrivates   Pipe private properties to override.
     * @param Request|null                               $request                The Request instance to use.
     * @return void
     */
    private static function runPipeTest(
        string $pipeClass,
        PipelineInput $pipelineInput,
        string $expectedOutput,
        string $expectedErrorOutput,
        ?callable $updateControlObject = null,
        bool $useClarityContext = false,
        array $traceIdentifiers = [],
        array $arrayOfContextMetaData = [],
        array $exceptionDTOs = [],
        ?Throwable $exception = null,
        array $internalException1DTOs = [],
        array $internalException2DTOs = [],
        array $overridePipePrivates = [],
        ?Request $request = null,
    ): void {

        // stop if the Clarity Context or Clarity Control packages aren't installed
        // Note: it's ok that this test isn't performed (Github actions runs the tests with and without)
        if ($useClarityContext) {
            if ((!class_exists(Clarity::class)) || (!class_exists(Control::class))) {
                self::assertTrue(true);
                return;
            }
        }



        // add meta-data context
        self::addContextMetaData($arrayOfContextMetaData[0] ?? []);
        $clarityContextLine1 = __LINE__ - 1;

        // add meta-data context on a different line
        self::addContextMetaData($arrayOfContextMetaData[1] ?? []);



        $context = self::newContext($useClarityContext, $updateControlObject);
        $context?->setTraceIdentifiers($traceIdentifiers);
        self::setPrivateProperty($pipelineInput, 'clarityContext', $context);



        $exception ??= self::buildException($exceptionDTOs);
        self::setPrivateProperty($pipelineInput, 'exception', $exception);

        if ($request) {
            Framework::depInj()->set(Request::class, $request);

            self::setPrivateProperty($pipelineInput, 'runningInConsole', false);
            self::setPrivateProperty($pipelineInput, 'consoleCommand', '');
        }



        $expectedOutput = self::replaceOutputTags($expectedOutput, $clarityContextLine1);
        $expectedErrorOutput = self::replaceOutputTags($expectedErrorOutput, $clarityContextLine1);
        $internalExceptions = self::buildInternalExceptions($internalException1DTOs, $internalException2DTOs);



        // run the pipeline when NO internal exceptions occur
        self::runPipeline(
            $pipeClass,
            $pipelineInput,
            $expectedOutput,
            [],
            $overridePipePrivates,
        );

        // run the pipeline when internal exception/s DO occur
        self::runPipeline(
            $pipeClass,
            $pipelineInput,
            $expectedErrorOutput,
            $internalExceptions,
            $overridePipePrivates,
        );
    }





    /**
     * Build Internal Exceptions based on ExceptionDTOs.
     *
     * @param ExceptionDTO[] $internalException1DTOs The ExceptionDTOs for the first internal exception.
     * @param ExceptionDTO[] $internalException2DTOs The ExceptionDTOs for the second internal exception.
     * @return Exception[]
     */
    private static function buildInternalExceptions(array $internalException1DTOs, array $internalException2DTOs): array
    {
        return array_filter([
            self::buildException($internalException1DTOs),
            self::buildException($internalException2DTOs),
        ]);
    }

    /**
     * Add context meta-data (will add up to two of them, on different lines).
     *
     * @param array<string|mixed[]> $arrayOfContextMetaData The meta data to add.
     * @return void
     */
    private static function addContextMetaData(array $arrayOfContextMetaData): void
    {
        if (!count($arrayOfContextMetaData)) {
            return;
        }

        MetaCallStackAPI::pushMultipleMetaData(
            InternalSettings::META_DATA_TYPE__CONTEXT,
            null,
            $arrayOfContextMetaData,
            1
        );
    }

    /**
     * Build an exception from an array of ExceptionDTOs.
     *
     * @param ExceptionDTO[] $exceptionDTOs The ExceptionDTOs.
     * @return Exception|null
     */
    private static function buildException(array $exceptionDTOs): ?Exception
    {
        $exception = null;
        foreach (array_reverse($exceptionDTOs) as $exceptionDTO) {
            $exception = $exception ? new Exception($exceptionDTO->message, $exceptionDTO->code, $exception) : new Exception($exceptionDTO->message); // phpcs:ignore
        }

        return $exception;
    }

    /**
     * Build a new Context instance.
     *
     * @param boolean       $useContext          Whether to use a context or not.
     * @param callable|null $updateControlObject A callable to update the control object before it's called.
     * @return Context|null
     * @throws Exception Doesn't throw this, but phpcs expects this to be here.
     *
     */
    private static function newContext(bool $useContext, ?callable $updateControlObject): ?Context
    {
        if (!$useContext) {
            return null;
        }

        Clarity::traceIdentifier(1234);

        $control = Control::prepare(fn() => throw new Exception())
            ->report(false)
            ->getException($returnedException);

        if (is_callable($updateControlObject)) {
            $updateControlObject($control);
        }

        $control->execute();

        return Clarity::getExceptionContext($returnedException);
    }

    /**
     * Replace tags in the expected output.
     *
     * @param string  $expectedOutput     The expected output containing tags.
     * @param integer $clarityContextLine The line number the Clarity Content was added.
     * @return string
     */
    private static function replaceOutputTags(string $expectedOutput, int $clarityContextLine): string
    {
        $projectRootDir = Framework::config()->getProjectRootDir();

        $functionsPathLong = "{$projectRootDir}tests/TestSupport/Functions.php";
        $functionsPathLong = str_replace('/', DIRECTORY_SEPARATOR, $functionsPathLong);
        $functionsPathLong = ltrim($functionsPathLong, DIRECTORY_SEPARATOR);

        $testPath = 'tests/Unit/Pipelines/LaravelPipeUnitTest.php';
        $testPath = str_replace('/', DIRECTORY_SEPARATOR, $testPath);

        $replace = [
            '%TEST_PATH%' => $testPath,
            '%TEST_PATH_LONG%' => ltrim(__FILE__, DIRECTORY_SEPARATOR),
            '%FUNCTIONS_PATH_LONG%' => $functionsPathLong,
            '%CONTEXT_METADATA_LINE_1%' => $clarityContextLine,
            '%CONTEXT_METADATA_LINE_2%' => $clarityContextLine + 4,
            '%EXCEPTION_THROWN_LINE%' => __LINE__ - 60,
            '%CONTEXTS_EXCEPTION_THROWN_LINE%' => __LINE__ - 38,
        ];
        return str_replace(array_keys($replace), array_values($replace), $expectedOutput);
    }





    /**
     * Run a pipeline and check the output.
     *
     * @param string        $pipeClass            The pipe class to run.
     * @param PipelineInput $input                The input to pass to the pipe.
     * @param string        $expectedOutput       The expected output.
     * @param mixed[]       $internalExceptions   The internal exceptions to use.
     * @param mixed[]       $overridePipePrivates Override pipe's private values (aid generation of situations only).
     * @return void
     */
    private static function runPipeline(
        string $pipeClass,
        PipelineInput $input,
        string $expectedOutput,
        array $internalExceptions,
        array $overridePipePrivates,
    ): void {

        // set up the pipe
        $output = new PipelineOutput();
        /** @var PipeInterface $pipe */
        $pipe = Framework::depInj()->make($pipeClass, ['input' => $input, 'output' => $output]);

        // override private properties of the Pipe object - for testing purposes only
        foreach ($overridePipePrivates as $key => $value) {
            self::setPrivateProperty($pipe, $key, $value);
        }

        // initial pass via "run"
        self::pipeCall($pipe, 'run');

        // second pass via "noInternalExceptionOccurred" or "internalExceptionOccurred"
        count($internalExceptions)
            ? self::pipeCall($pipe, 'internalExceptionOccurred', ['exceptions' => $internalExceptions])
            : self::pipeCall($pipe, 'noInternalExceptionOccurred');

        // replace the line number of the "caller" (in this case it's the last frame inside the test class)
        $replace = [
            '%CALLER_LINE%' => __LINE__ + 24,
        ];
        $expectedOutput = str_replace(array_keys($replace), array_values($replace), $expectedOutput);

        // check the output
        self::assertSame($expectedOutput, $output->getCombinedOutput());
    }

    /**
     * Call a method on a Pipe object.
     *
     * @param PipeInterface $pipe       The pipe to call the method on.
     * @param string        $method     The method to call.
     * @param mixed[]       $parameters Extra parameters to include.
     * @return void
     */
    private static function pipeCall(PipeInterface $pipe, string $method, array $parameters = []): void
    {
        $toCall = [$pipe, $method];
        if (!is_callable($toCall)) {
            return;
        }

        try {
            Framework::depInj()->call($toCall, $parameters);
        } catch (Throwable) {
            // do nothing
        }
    }

    /**
     * Set the private property of an object.
     *
     * @param object $object       The object to set the property on.
     * @param string $propertyName The name of the property to set.
     * @param mixed  $newValue     The new value to set.
     * @return void
     */
    private static function setPrivateProperty(object $object, string $propertyName, mixed $newValue): void
    {
        $reflection = new ReflectionClass($object);
        $reflectionProperty = $reflection->getProperty($propertyName);
        $reflectionProperty->setAccessible(true);
        $reflectionProperty->setValue($object, $newValue);
    }



    /**
     * Generate time strings, formatted relative to each other.
     *
     * @param CarbonImmutable $carbon    The CarbonImmutable object to format.
     * @param string[]        $timezones The timezones to use.
     * @param string[]        $format    The format to use.
     * @return string[]
     */
    private static function formatTimeStrings(CarbonImmutable $carbon, array $timezones, array $format): array
    {
        $parts = [];
        $lengths = [];
        foreach ($timezones as $index => $timezone) {

            /** @var CarbonImmutable $tempCarbon */
            $tempCarbon = $carbon->copy()->tz($timezone);

            foreach ($format as $index2 => $format2) {
                $parts[$index][$index2] = $tempCarbon->format($format2);
                $lengths[$index2] = max($lengths[$index2] ?? 0, strlen($parts[$index][$index2]));
            }
        }

        $timeStrings = [];
        foreach (array_keys($parts) as $index) {
            $temp = [];
            foreach ($parts[$index] as $index2 => $b) {
                $temp[] = str_pad($b, $lengths[$index2]);
            }
            $timeStrings[$index] = implode(' ', $temp);
        }

        return $timeStrings;
    }

    /**
     * Piece the time strings together.
     *
     * @param string[] $timeStrings The time strings to piece together.
     * @return string
     */
    private static function buildTimeStrings(array $timeStrings): string
    {
        $lines = [];
        foreach ($timeStrings as $timeString) {
            $lines[] = !count($lines)
                ? 'date/time  ' . $timeString
                : '           ' . $timeString;
        }

        return implode(PHP_EOL, $lines);
    }
}
